变量：变量的本质就是内存中的一段空间，这段空间是有地址的。只能以下划线和字母保留字开头，而且不能为保留字，不能以数字开头，无法区分数字和变量。

变量作用域：1.全局变量：在函数外面
			2.局部变量：在函数里面，默认情况下，函数内部是不能访问函数外部变量的。
			  如果想在函数内部访问全局的变量则需要用$GLOBALS['var'];在函数内部写$GLOBALS['var'] = 10;就相当于在函数外部声明了$var = 10;
			  此时$var以然是全局变量了。
			  $GLOBALS是个数组，包换所有全局变量的值。
			  另外，global关键字的使用 -- 可以将变量地址引入函数内部
			  <?php 
					$num = 10;
					function show(){ 
						echo $num; //报错，未定义变量$num
						global $num ;//将全局变量$num的地址引入到函数内部，因为默认情况下函数内部不能使用全局变量$num
						echo $num; //10
						$num = 100;
					}
					show();
					echo $num; //100
			  ?>
				
			3.超全局变量：可以在函数内部和函数外部访问。如$_COOKIES,$_GET,$_POST
			注意：常量没有作用域的概念。
			
			总结：如何在函数内部访问函数外部变量（或者说全局变量）？
				1.使用超全局变量；
				2.使用$GLOBALS全局变量数组；
				3.使用global关键字，将全局变量的地址引入函数内部；
				4.use将函数外部变量引入到函数内部中。（前提是匿名函数，且只引入外面一层，函数包含的函数也算一层）
			
			

可变变量：$a = 'tom'; $b = 'a'; $$b 为 'tom' ,$$b可以理解为$($b == 'a')即$a, 作用：随机几率的功能。

销毁变量：unset销毁的是变量名，变量值由php垃圾回收机制销毁。可通过&地址传值引证。垃圾：没有变量指向（引用）的值就是"垃圾"。

常量：1.define('NAME', 'tom');     //定义常量
	    define('NAME', 'tom',true);//定义常量，不区分大小写
		或者：const NAME = 'tom';
		总结：define和const的区别？
		- 使用const使得代码简单易读，const本身就是一个语言结构，而define是一个函数。另外const在编译时要比define快很多。
		- const用于类成员变量的定义，一经定义，不可修改。Define不可以用于类成员变量的定义，可用于全局常量。
		- Const可在类中使用，define不能
		- Const不能在条件语句中定义常量
		
      2.使用特殊字符当常量名，调用时要用constant
		define('%-%','abc'); echo constant('%-%');
		
	  3.常量一经定义 不能在次定义，建议定义前先判断:if(!defined('NAME'));

魔术常量：会“变化”的常量,会随着代码位置的改变而改变，有七个。__LINE__、__CLASS__、__FILE__、__DIR__、FUNCTION__、__METHOD__、__NAMESPACE__;

字符串：字符串定界符<<< ,如:<<<lizi asdasdadasdasd  lizi; 会输出asdasdadasdasd，以lizi开始和结束。
		<<<lizi $var lizi;能解析变量(heredoc 双引号)。
		<<<'lizi' lizi;不能解析变量(nowdoc 单引号)。
		可以直接在html网页上php代码中使用定界符嵌入js
		<?php
			echo <<<str                  //必须放在首行
				<script>  ... </script>; //将这段js代码当作字符串处理
			str;
		?>

数组：本质为变量，在内存中的一段连续的空间。目的是保存同一类型的多个值。
    1.分为索引数组和关联数组两种。索引数组下标指定数字，后面的自动加1，相同数字下标，后面的值覆盖前面的。
	  $array[true] = 'tom'; //下标为1
	  $array[false] = 'aymi';//下标为0
	  $array[12.9] = 'aymi';//下标为12
	  $array[-12.9] = 'aymi';//下标为-12
	  $array[-12] = 'aymi';//下标为-12
	  $array['12'] = 'aymi';//下标为整数12
	  $array[''] = 'aymi';//下标为空字符串,空字串也可以作为下标
	  $array[null] = 'aymi';//下标为空字符串,空字串也可以作为下标
	  
    2.在php版本7.1及以上支持数组赋值。如下面两个值交换
	  $num1 = 10; $num2 = 20;
	  [$num1,$num2] = [$num2,$num1];
	  //交换位置
	  $array = ['aa','bb','cc','dd','ee'];
	  for($i=0,$j=(count($array)-1); $i<=$j; $i++,$j--){
	//	[$array[$i],$array[$j]] = [$array[$j],$array[$i]]; 
		$temp = $array[$i];
		$array[$i] = $array[$j];
		$array[$j] = $temp;
	  }
	  
    3.字符串可以通过数组的方式去调用,'abc'[0]为 a ，'abc'[-1]为 c 从右边去第一个.
	
类型转换：和布尔之间的转换：
		1.数字：0为false，非0为true；
		2.字符串和数组：一个字符如果能转成0或空则为false，否则为true，'null','0.0','false'为true，'0'为false。即0和空为false，其他为true。
		总的：0、空为false，非0非空为true。
	  
中断循环：break、continue默认中断、跳过1重循环。如果要中断、跳过多重循环，则在后面增加一个数字，如break 2；//中断2重循环
	for(...){
			switch($int){
			case 5: break 2;//中断最外层的for循环，switch本质是循环一次的循环。
		}
	  
	}
	
函数：一段代码块。目的是实现模块化编程。

可变函数：将函数名存储到变量中。目的是优美化编程！?
		如：function showImg(){ ... }
			$fun = 'showImg';
			$fun();
			
匿名函数：就是没有名字的函数。
		如：$fun = function(){ ... }; //后面要加逗号，当作声明变量一样
			$fun();
		默认情况下，函数内部是不能访问函数外部变量的。但匿名函数使用use可以将外部变量引入匿名函数中，且只引入外面一层，即函数包含的函数也算一层
		如：<?php
				$num = 10;
				$fun = function() use(num){
					echo $num; 
				};
				$fun(); //10
			?>
	        
函数传参：1.默认的是值传递。
		  2.地址传递需要加&。当地址传递的时候不能直接传值如10，因为只有变量才有地址。
		如：function show(&$args){ ... }
			$show(10);//会报错，地址传递不能直接传值。
	
函数参数：1.参数默认值：有默认的值要写后面；变量不可当默认值；然而常量可以当默认值。
		  2.参数个数：实参多于形参会报错；实参多余形参只取前面对应的。
		  3.php内置函数取个数与值：func_num_args 获取参数的个数；func_get_args 获取参数以数组形式表现出来。
		  4.可变参数：...$var $var以数组形式表现出来,不传则为空数组，实参可传数组。如function show(...$var){}、function show($name,...$var){}
				实参时传输组将其展开：function show(...$var){ print_r(var) }
				$num = [10,20];
				show(num);// Array( [0]=>Array( [0]=>10,[1]=>20 ) ); //两个数组
				show(...num);// Array( [0]=>10,[1]=>20 );//利用可变参数将数组展开，只有一个数组
		  5.参数类型约束：PHP7以后支持强类型约束
				返回值必须是整型：function fun(int $num):int{ ... }
				返回值必须是数组：function fun(int $num):array{ ... }
				返回值必须是空,即不能有返回值：function fun(int $num):void{ ... } //PHP7.1以后支持
				可以约束的有：string、int、float、bool、array、void(PHP7.1以后支持)
	  
return: 1.终止当前脚本执行，如果有包含文件，包含文件的return只能终止其本身的执行，不能影响其他页面；
			如果想完全终止脚本（其他页面）的执行，则使用exit()或者die。
	  
	    2.返回页面结果。如test.php 中 <?php return ['name'=>'tom','age'=>20]; ?>
			<?php
				$info = require './test.php';  //使用test.php文件并赋值给info
				print_r($info); //Array([name]=>tom [age]=>20);
			?>
	    3.函数的返回和终止。
	  
静态变量：1.一般指的是静态局部变量，没有静态全局变量这个说法，要不就说全局变量。
		  2.静态变量只初始化一次（声明的同时要初始化），而普通变量每调用一次就初始化一次。
	  
静态变量和常量的区别：1.两者都是初始化一次。
					  2.常量不能改变值，静态变量可以改变值。
					  3.常量没有作用域，静态变量有作用域。
	  
递归：函数自己调用自己。两元素：递归点、递归出口。
		如：斐波那契数列 1 1 2 3 5 8 ...
		<?php
			function fbnq($n){  //打印第n个斐波那契数
				if($n==1 || $n==2)
					return 1;
				return fbnq($n-1) + fbnq($n-2);
			}
			//打印前十个斐波那契数列的值
			for($i=1; $<=10; $i++){
				echo fbnq($i).'&nbsp;';
			}
		?>
	  
包含文件方式：1.require  遇到错误抛出error级别错误，停止执行。包含多次。
				require_once 包含一次
			  2.include  遇到错误抛出warnning级别错误，继续执行。包含多次。
				include_once 包含一次
			  3.包含文件相当于 把包含文件的代码拷贝到主文件中，魔术常量除外，魔术常量获取的是所在文件的信息。
			  4.包含文件在编译时不执行，运行时加载到内存，独立编译包含文件。
			  5.require './head.html';  //在当前目录下找head.html
			  6.require 'head.html';    //受include_path影响，在include_path下从左到右依次查找，可通过set_include_path设置
			  
错误处理：error_reporting = E_ALL;  //报告所有错误
		  display_errors = on;      //将错误显示在浏览器上
		  log_errors = on;          //将错误记录在日志中
		  error_log = '地址';       //错误日志保存的地址
		  ini_set('error_reporting',E_ALL);//可通过ini_set修改php.ini配置文件，不需要重启
		  
文件夹操作：1.创建 	mkdir  如：mkdir('文件名',[权限如0777],[true|false(是否递归创建，默认false)]);  //默认不能递归创建
			2.删除  rmdir  如：rmdir('文件名') //不能递归删除，即只能删除空的文件夹
			3.重命名文件夹  rename 如：rename('旧名字','新名字');
			4.是否文件夹 is_dir  如：is_dir('文件夹名');
			5.打开文件夹 opendir 如：opendir('文件夹名'); //返回的是一个资源标识
			6.读取文件夹 readdir 如：readdir(文件夹标识); //需要传入打开文件夹时返回的标识
			7.关闭文件夹 closedir 如：closedir(文件夹标识);
			如：列出一个文件夹下的文件
				$folder = opendir('./');
				while($f = readdir($folder)){
					if($f == '.' || $f == '..') //文件夹下的第一个文件名和第二个文件名分别.和..，他们是隐藏的
						continue;
					echo iconv('gbk','utf-8',$f),'<br/>'; //gbk转成utf-8。中文系统下的文件名字需要转码，因为浏览器是utf-8编码。
				}
				closedir($folder);
				注：我们操作系统是中文的 即是gbk gb2312 ，所以php程序在中文系统中拿到的资源是gbk编码的，
					然而浏览器多数是utf-8的，所以中文系统php程序拿到的gbk编码的东西在浏览器上是乱码
				
			如：循环遍历一个文件夹下的所有文件
				function dirList($dir_path = '') {
					 if(is_dir($dir_path)) {
						 $dirs = opendir($dir_path);
						 if($dirs) {
							while(($file = readdir($dirs)) !== false) {
								 if($file !== '.' && $file !== '..') {
									 if(is_dir($file)) {
										 echo $dir_path . '/' . $file . '<br>';
										 dirList($dir_path . '/' . $file);
									 } else {
										 echo $dir_path . '/' . $file . '<br>';
									 }
								 }
							 }
							 closedir($dirs);
						 }
					 }else {
						 echo '该目录不存在！';
					  }
				}
				
文件操作：1.将字符写入文件： file_put_contents	file_put_contents('文件名地址','字符串');
			小结：1.所有“写”操作都是清空重写。
				  2.在文本中换行是\r\n。\r:回车（光标移动到当前行的最前面）。\n：换行。文本中要\r\n才能换行
				  3.\r\n是特殊字符，必须放在双引号内。
				
		  2.读取文件到一个字符串：1.file_get_contents - 将整个文件读入一个字符串
					  2.readfile - 读取输出文件内容
					   注：echo file_get_contents('文件名地址') == readfile('文件名地址');
					   
		  3.打开文件并操作：fopen fopen('文件名地址','模式'); 如：$fp = fopen('./test.txt','w'); //打开文件返回文件指针（文件地址）。循环写时会返回当前地址
							r：读 read
							w：写（清空写,不存在则新建文件） write 
							a：追加 append
		  4.写入文件一行：fputs fputs(文件指针,字符串); 如：fputs($fp,'abc'); //循环写时会返回当前地址
		  
		  5.读取文件一行：fgets fgets(文件指针); 如：fgets($fp); //循环读时会返回当前地址
		  
		  6.关闭文件：fclose
		  
		  7.删除文件：unlink('地址'); //文件不存在则报错
		  小结：1.打开文件，返回文件指针（文件指针就是文件地址），资源类型。
				2.打开文件写、追加操作，如果文件不存在就会创建新的文件。
				
		  8.二进制读取：fread(文件指针,文件大小);
		  如：$path = './face.jpg'; //图片
			  $fp = fopen($path,'r');
			  header('content-type:image/jpeg'); //告知浏览器下面的代码通过jpg图片的方式解析（默认是以字符串形式解析，ie除外）
			  echo fread($fp,filesize($path));
		  
			普通读取：
				header('content-type:image/jpeg');
				echo file_get_contents('./face.jpg');  //file_get_contents也可以进行二进制读取
			
		  小结：1.文件的存储有两种：字符流和二进制流。二进制流的读取按文件大小来读的。
				2.文本流有明确的结束符。二进制流没有明确的结束符，通过文件大小来判断是否读取完毕。
				3.file_get_contents既可以进行文本流读取，也可以进行二进制读取。
				

文件/文件夹判断：1.是否是文件：is_file('地址');
				 2.是否是文件夹：is_dir('地址');
				 3.文件或文件夹是否存在：file_exists('地址');
				
表单enctype属性：默认情况下，表单传递的是字符流，不能传递二进制流。如果传递音乐、图片、视频这种二进制数据，则必须设置enctype="multipart/form-data"
				1.application/x-www-form-urlencoded (默认) ，字符流，带格式的文本数据，将数据整体打包成xml传递。
				2.multipart/form-data 复合的表单数据，既能传递字符流又能传递二进制流。文件上传必须设置此类型。文件属于二进制流。
				3.text/explain 无格式的文本数据，主要用户电子邮件。
				注：表单允许上传的最大值设置
				<form ...>
					<input type="hidden" name="MAX_FILE_SIZE" value='10'></input> //必须在表单最上面，MAX_FILE_SIZE固定写法，value为多少字节，此为10字节
				</form>
				
文件上传：$_FILES['文件名字']['error'] error为0则上传成功 error为4则上传失败
			如：if($_FILES['文件名']['error'] == 0){
					move_uploaded_file($_FILES['文件名']['tmp_name'],'文件新名字');
				}else{
					echo '上传有误错误码为:'.$_FILES['文件名']['error'];
				}
			
字符集和校对集：字符集和校对规则是一对多的关系。校对集不同，排序就不一样。   			

	  
	  
	  
	  