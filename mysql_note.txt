{
group by:要求select后面加分组函数和group by后面出现的字段,有where条件的要在from表的后面,order by 子句
如：select 列（要求出现在group by的后面）,分组函数
	from 表
	【where 筛选条件】
	group by 要分组的列，要求在select的后面也要出现
	【having 筛选条件】
	【order by 子句】

注意点：                  数据源            位置                    关键字
		分组前筛选  	  原始表            group by子句的前面       where
		分组后筛选        分组后的结果集    group by子句的前面       having
		
重点：  1.分组函数做条件肯定是放在having子句中；
		2.能在分组前筛选的，就优先考虑使用分组前筛选（性能）（在分组前后都有的字段下）；
		3.group by子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开且没有顺序要求），表达式或函数（用得较少）；
		4.也可以添加排序（排序放在整个分组查询的最后）
		
小结：	1.如果是分组查询，查询字段必须是分组字段（在group by后面的）和聚合函数；
		2.查询字段是普通字段（不在group by后面的），只取第一个值。
	
//简单查询条件,分组前的查询条件（在同一个表里），where后面的条件字段在from后面的表里
--查询每个班级最高的分数
select class_id ,max(score) from class group by class_id;

--查询邮箱中包含a字符的，每个部门的平均工资
select department_id, avg(salary) from employees where emall like '%a%' group by department_id;

--查询有奖金的每个领导手下员工的最高工资
select manager_id,max(salary) from employees where 奖金字段 is not null group by manager_id;

//复杂查询条件，分组后的查询条件（可能不在一个表里）
--查询哪个部门的员工个数>2
1.查询每个部门的员工个数
select department_id,count(*) from employees group by department_id;
2.根据1.的结果进行筛选，查询哪个部门的员工个数>2，所以结果为
select department_id,count(*) from employees group by department_id having count(*)>2;

--查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资
1.查询每个工种有奖金的员工的最高工资
select job_id,max(salary) from employees where 奖金字段 is not null group by job_id;
2.根据1.的结果进行筛选，最高工资>12000,所以结果为
select job_id,max(salary) from employees where 奖金字段 is not null group by job_id having
max(salary)>12000;

--查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个，以及其最低工资
1.查询每个领导手下员工的最低工资
select manager_id,min(salary) from employees group by manager_id;
2.添加筛选条件，领导编号>102
select manager_id,min(salary) from employees where manager_id>102 group by manager_id;
3.继续添加筛选条件，最低工资>5000,所以结果为
select manager_id,min(salary) from employees where manager_id>102 group by manager_id having
min(salary)>5000;

//按表达式或函数分组
--按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些
1.查询每个长度的员工个数
select count(*),length(last_name) len_name from employees group by length(last_name);
2.添加筛选条件
select count(*) c,length(last_name) len_name from employees group by len_name having c>5;

//按多个字段分组
--查询每个部门每个工种的员工的平均工资
select department_id,job_id,avg(salary) from employees group by department_id,job_id;

//添加排序
--查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示
select department_id,job_id,avg(salary) from employees group by department_id,job_id order by avg(salary) desc;

--查询每个部门每个工种的员工的平均工资>10000，并且按平均工资的高低显示
select department_id,job_id,avg(salary) a from employees group by department_id,job_id having a>10000 order by a desc;

--查询员工最高工资和最低工资的差距
select max(salary)-min(salary) difference from employees;
}

字符集和校对集：字符集和校对规则是一对多的关系。校对集不同，排序就不一样。  

（唯一性索引）
主键和唯一键： 异： 1.主键是只有一个且不能为空。
				    2.唯一键可以有多个且可以为空。
			   同： 3.主键和唯一键的值都不能重复。

外键：表的一个公共字段，在主表里是一个字段（可能也是主键），在从表里却是主键（可能也不是主键，但必须是唯一性索引）。
	  有三种外键操作：1.严格限制。如下笔记。
					  2.置空操作。当主表删除时，从表的外键字段为null。foreign key(字段) references 主表（字段）on delete set null；
					  3.级联操作。当主表更新时，从表的外键字段也更新。foreign key(字段) references 主表（字段）on update cascade；
					  置空、级联合在一起写：foreign key(字段) references 主表（字段）on delete set null on update cascade；
					  注：置空、级联操作中外键不能为从表的主键。
外键约束：创建表时：foreign key(字段) references 主表（字段）；
		  修改时：alter table 从表 add foreign key（字段）references 主表（字段）；
		  删除时：alter table 从表 drop foreign key `外键名`；
		  注：哪个表使用foreign...就是从表
				规则（严格限制）：1.从表插入的记录必须主表有的。
								  2.主表删除的记录必须先删从表。
								  3.删除主表前，先删从表。
								  4.名字可以不一样，但类型要一样。
								  5.mysql中必须innodb才支持。
			
解决主键冲突：语法一：将insert into 改成 replace into （不重复直接插入，重复则先删除原来的在插入。两步）
		      语法二：on duplicate key update（推荐。不重复直接插入，重复则更新操作。一步）
					如:insert into 表名 values('xx','xx') on duplicate key update 字段='xx';
			
实体之间的关系：一对一：主键与主键建立关系。
				一对多：主键与非主键建立关系。
				多对多：利用第三张关系表。
			
数据规范化：三大范式：
		第一范式：确保每列的原子性（不可再分，最终取决于统计和运算）。（一个字段表示一个含义,约束所有字段）
		第二范式：非主键字段必须依赖于主键字段。在满足第一范式的前提下，要求每个表只描述一件事情。（非主键列要与主键有关系，约束主键与非主键）
		第三范式：非主键间消除传递依赖。在满足第二范式的前提下，除了主键之外的其他列消除传递依赖。（一个或多个非主键列能够推断另一个非主键列时，则另一个主键列就不写，即非主键间不能有依赖关系，约束非主键间）
			如：学号、姓名、语文、数学、总分不满足第三范式，因为语文、数学可以推断总分，应把总分去掉才满足。（实际上很多时候是保留总分的--反3NF）
			小结：1.范式越高，冗余越少，但表越多。
				  2.规范化与性能关系：性能比规范化更重要（反3NF）
				  
dual表：伪表，为了保证语句的完整性。如select 10*10；这里面没有表参与，等价于 select 10*10 from dual；
			
			
			


  