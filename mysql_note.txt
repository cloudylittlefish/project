{

										  (默认)						
										  [输入值/输出值/输入输出值]					
存储过程:create procedure procedure_name([in/out/inout] 参数名 参数类型,...)
delimiter $
create procedure pro_test()
begin
	declare num int default 5;
	set num = num+10;
	select concat('num的值为:',num);
end$
delimiter ;
调用存储过程：call pro_test([输入的值，接收的变量(@value)]);
查询存储过程返回的变量值：select @value;


函数：create function function_name([参数 类型, ...])
		returns 类型
		begin
			...
		end;
		
delimiter $
create function city(id int)
returns int
begin 
	declare num int;
	select count(*) into num from table where city_id = id;
	return num;
end$
delimiter ;	
调用函数：select 函数名（...）;

删除：drop procedure/function 名字;			

存储过程和函数的区别在于函数必须有返回值，而存储过程不用。
函数：是一个有返回值的过程；
过程：是一个没有返回值的函数；


数据库设计三范式：第一（单一属性）、第二（中间表）、第三范式（间接依赖）。

索引笔记：
1.索引最左前缀法则，复合索引，就像上楼梯，如必须一层一层上去（从左边开始），不能跳过，跳过只取前面索引。
	where后面与写的顺序无关，与有没有包含有关。
2.范围判断时如 被between >= ，从该语句的右边的索引失效。
3.进行数值运行时如substing 赋值运算（包括原本字段为varchar字段类型，但进行赋值时没加引号''），索引失效.
4.or条件连接时，其中一个条件没有索引则整个语句索引失效。而且or不走复合索引，必须单列索引。
5.模糊查询%时，%加在后面如string%索引生效；%加在前面如%string则索引失效，要想%加在前面如%string则索引失效，要想%加在前面索引
	也生效则需要覆盖索引来解决（指定已有的索引字段）。
6.如果mysql评估使用索引比全表扫描更慢，则不使用索引，这是底层的优化。（大多数相同，极少数不同，全表扫描）
7.is null, is not null有时索引失效（根据数据库数据量决定，根据mysql评估使用哪个更快）。
8.in 走索引，not in索引失效。
9.尽量使用复合索引，而少使用单列索引。因为多个字段同时搜索单列索引只会使用最优（辨识度最高的索引）的一个，而不会
	像复合索引那样全部走索引。
10.查看索引使用情况：show [global] status like 'Handler_read%';


大量数据插入(导入)优化：
1.主键顺序插入，排好序，Inodb是二叉树结构。
2.关闭唯一性校验，set unique_checks=0;
3.手动提交事务，关闭自动提交事务，set autocommit=0;
 
insert插入优化：
1.多条语句插入改为一条语句插入。
2.手动提交事务插入。 
3.数据有序插入 .

order by 排序优化（using index）:
1.覆盖索引排序（避免使用*）。 
2.多字段排序，统一排序方式，要么升序 要么降序。
3.多字段排序要与索引字段顺序保持一致。
4.filesort优化，适当提高max_length_for_sort_data和sort_buffer_size系统变量排序区的大小。


group by 优化：
1.group by 也是排序操作，只是多了排序之后的分组操作。如果还多了一些聚合函数，还需要一些聚合函数的计算。
	所以优化可以在 group by + order by null 只是分组而不排序。
2. 创建索引，搜索有索引的字段 如select 索引字段 group by 索引字段 order by null;



or 优化(尽可能使用并集union)：
1.select * from table where id=1 or id=10;
	select * from table where id=1 union select * from table where id=10;


limit 优化
1. select * from table1 limit 2000000,10; 
优化为 select * from table1 t1, (select id from table1 order by id limit 2000000,10) t11 
	where t1.id = t11.id; 间接通过索引来查
	
2. select * from table1 limit 2000000,10; 
优化为 select * from table where id>2000000 limit 10;
	该适合于主键自增的表，且有断层的话数据不准确.
	 

使用sql提示
1. select * from table 【use/ignore/force index(index1)】 where ... 提示mysql使用/忽视/强制使用 index1这个索引.


查询缓存
是否支持 show variables like 'hava_query_cache';
是否开启 show variables like 'query_cache_type';
缓存占用大小  show variables like 'query_cache_size';
查看缓存族（状态变量） show status like 'Qcache%';
开启查询缓存 只需在/usr/my.cnf配置中 query_cache_type=1

查询缓存失效情况：
1.语句不完全一致，如查询语句大小写。
2.包含不确定的函数时，如now(),rand(),current_date(). 
3.不使用任何表查询语句，如select 'A';(A代表变量或常量)。
4.查询系统数据库时，如mysql。
5.存储过程，函数，触发器主体内执行的查询。
6.表更改时，如表映射，增删改查。


（MyISAM）锁：
写锁（共享锁）：一个用户对一个表启用的写锁，本身无法再访问别的表，也无法进行其他操作，直到解锁。别的用户（线程）
	能访问锁的表，也能访问别的表，但无法对锁的表进行其他操作（会阻塞），直到解锁。
读锁（排他锁）：当前用户（线程）可以进行读写操作，别的用户（线程）不能进行读写操作（会阻塞）。
简而言之，读锁会阻塞写，但不会阻塞读。写锁，既会阻塞读，也会阻塞写。


查看锁的的情况：
 1.show open tables;(in use)
 2.show status like 'Table_locks%';

 
(InnoDB)锁：支持行锁，和事务配合使用，要setautocommit=0;
1.无索引行锁升级为表锁，如果不通过索引条件（包括索引失效情况），行锁会升级为表锁。
2.间隙锁危害。使用范围条件时，并请求共享或排他锁时诱发。如ID>10,但只有123579，中间少了几个。


 innodb行锁争用情况：
 show status like 'innodb_row_lock%';


优化建议：
1.尽可能让所有 数据都能通过索引来完成，避免无索引行锁升级为表锁。
2.合理设计索引，尽量缩小锁的范围。
3.尽可能减少索引条件及索引范围，避免间隙锁。
4.尽量控制事务大小（线程次数），减少锁定资源量和时间长度。
5.尽可能使用低级别事务隔离（但是需要业务层面满足需求）。

Mysql日志：
查看日志：show variables like 'log_error%';


bin日志默认关闭 要配置
vi /usr/my.cnf
log_bin=mysqlbin
binlog_format=statement


非递归调用方法实现无限分类表结构
create table class(
	id int(11) not null auto_increment,
	catPath varchar(100) not null comment '分级路径',
	title varchar(100) default '' comment '栏目标题'
)
形式：
id		catPath			title
1		0				网站首页
2		0-1				Linux OS
3		0-1				Apache服务
4 		0-1-2			...

查询方式
select id,concat(catPath,'-',id) as absPath, title from tablename order by absPath,id;


主从复制：
从上层来看，复制分成三步（前提开启二进制日志）：
1.Master主库在事务提交时，会把数据变更作为时间Events记录在二进制日志文件Binlog中。
2.主库推送二进制文件Binlog中的日志事件到从库的中继日志Relay Log。
3.slave重做中继日志中的事件，将改变反映它自己的数据。

复制优势：
1.主库出现问题，可以快速切换到从库提供服务。
2.可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。
3.可以在从库中执行备份，以避免备份期间影响主库的服务。
}


{
group by:要求select后面加分组函数和group by后面出现的字段,有where条件的要在from表的后面,order by 子句
如：select 列（要求出现在group by的后面）,分组函数
	from 表
	【where 筛选条件】
	group by 要分组的列，要求在select的后面也要出现
	【having 筛选条件】
	【order by 子句】

注意点：                  数据源            位置                    关键字
		分组前筛选  	  原始表            group by子句的前面       where
		分组后筛选        分组后的结果集    group by子句的前面       having
		
重点：  1.分组函数做条件肯定是放在having子句中；
		2.能在分组前筛选的，就优先考虑使用分组前筛选（性能）（在分组前后都有的字段下）；
		3.group by子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开且没有顺序要求），表达式或函数（用得较少）；
		4.也可以添加排序（排序放在整个分组查询的最后）
		
小结：	1.如果是分组查询，查询字段必须是分组字段（在group by后面的）和聚合函数；
		2.查询字段是普通字段（不在group by后面的），只取第一个值。但是可以用group_concat（普通字段）将同一组的多个值写在一起。
	
	
//简单查询条件,分组前的查询条件（在同一个表里），where后面的条件字段在from后面的表里
--查询每个班级最高的分数
select class_id ,max(score) from class group by class_id;

--查询邮箱中包含a字符的，每个部门的平均工资
select department_id, avg(salary) from employees where emall like '%a%' group by department_id;

--查询有奖金的每个领导手下员工的最高工资
select manager_id,max(salary) from employees where 奖金字段 is not null group by manager_id;

//复杂查询条件，分组后的查询条件（可能不在一个表里）
--查询哪个部门的员工个数>2
1.查询每个部门的员工个数
select department_id,count(*) from employees group by department_id;
2.根据1.的结果进行筛选，查询哪个部门的员工个数>2，所以结果为
select department_id,count(*) from employees group by department_id having count(*)>2;

--查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资
1.查询每个工种有奖金的员工的最高工资
select job_id,max(salary) from employees where 奖金字段 is not null group by job_id;
2.根据1.的结果进行筛选，最高工资>12000,所以结果为
select job_id,max(salary) from employees where 奖金字段 is not null group by job_id having
max(salary)>12000;

--查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个，以及其最低工资
1.查询每个领导手下员工的最低工资
select manager_id,min(salary) from employees group by manager_id;
2.添加筛选条件，领导编号>102
select manager_id,min(salary) from employees where manager_id>102 group by manager_id;
3.继续添加筛选条件，最低工资>5000,所以结果为
select manager_id,min(salary) from employees where manager_id>102 group by manager_id having
min(salary)>5000;

//按表达式或函数分组
--按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些
1.查询每个长度的员工个数
select count(*),length(last_name) len_name from employees group by length(last_name);
2.添加筛选条件
select count(*) c,length(last_name) len_name from employees group by len_name having c>5;

//按多个字段分组
--查询每个部门每个工种的员工的平均工资
select department_id,job_id,avg(salary) from employees group by department_id,job_id;

//添加排序
--查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示
select department_id,job_id,avg(salary) from employees group by department_id,job_id order by avg(salary) desc;

--查询每个部门每个工种的员工的平均工资>10000，并且按平均工资的高低显示
select department_id,job_id,avg(salary) a from employees group by department_id,job_id having a>10000 order by a desc;

--查询员工最高工资和最低工资的差距
select max(salary)-min(salary) difference from employees;

having：在结果集上作筛选。结果集上没有的字段作筛选会报错。如select name...这个结果集只有name的字段，则having只能在name上作筛选。
		having和where的区别：where是在原始数据上（表）作筛选，having是在记录集上作筛选。
		
前多少名=》排序=》order

limit在update和delete语句中也可以使用的，配合order。
	如：前三名语文成绩加一分
		update 表 set 语文=语文+1 order by 总分 desc limit 3；
		
注：字段属性集合set，插入数据时是数字（插入多个时相加），依次为2的n次方。如（'aa','bb','cc'）2的0次方为aa，2的1次方为bb
	insert ...values(1);//此时插入的为'aa'
	insert ...values(2);//此时插入的为'bb'
	insert ...values(3);//此时插入的为'aa'和'bb'

[选项] select查询语句中的选项有两个：1.all（全部显示，默认）
							         2.distinct （去重）
						
union [选项]:将多个select语句结果集纵向联合起来。可以将一个复杂的条件（or）转换成两个简单的条件。
	union语句中的选项有两个：1.all（全部显示）
							 2.distinct （去重，默认）
	注：1.union两边的select语句的字段个数必须一致。
		2.union两边的select语句的字段名可以不一致，最终按第一个select语句的字段名。
		3.union两边的select语句的数据类型可以不一致。
}

字符集和校对集：字符集和校对规则是一对多的关系。校对集不同，排序就不一样。  

（唯一性索引）
主键和唯一键： 异： 1.主键是只有一个且不能为空。
				    2.唯一键可以有多个且可以为空。
			   同： 3.主键和唯一键的值都不能重复。

外键：表的一个公共字段，在主表里是一个字段（可能也是主键），在从表里却是主键（可能也不是主键，但必须是唯一性索引）。
	  有三种外键操作：1.严格限制。如下笔记。
					  2.置空操作。当主表删除时，从表的外键字段为null。foreign key(字段) references 主表（字段）on delete set null；
					  3.级联操作。当主表更新时，从表的外键字段也更新。foreign key(字段) references 主表（字段）on update cascade；
					  置空、级联合在一起写：foreign key(字段) references 主表（字段）on delete set null on update cascade；
					  注：置空、级联操作中外键不能为从表的主键。
外键约束：创建表时：foreign key(字段) references 主表（字段）；
		  修改时：alter table 从表 add foreign key（字段）references 主表（字段）；
		  删除时：alter table 从表 drop foreign key `外键名`；
		  注：哪个表使用foreign...就是从表
				规则（严格限制）：1.从表插入的记录必须主表有的。
								  2.主表删除的记录必须先删从表。
								  3.删除主表前，先删从表。
								  4.名字可以不一样，但类型要一样。
								  5.mysql中必须innodb才支持。
			
解决主键冲突：语法一：将insert into 改成 replace into （不重复直接插入，重复则先删除原来的在插入。两步）
		      语法二：on duplicate key update（推荐。不重复直接插入，重复则更新操作。一步）
					如:insert into 表名 values('xx','xx') on duplicate key update 字段='xx';
			
实体之间的关系：一对一：主键与主键建立关系。
				一对多：主键与非主键建立关系。
				多对多：利用第三张关系表。
			
数据规范化：三大范式：
		第一范式：确保每列的原子性（不可再分，最终取决于统计和运算）。（一个字段表示一个含义,约束所有字段）
		第二范式：非主键字段必须依赖于主键字段。在满足第一范式的前提下，要求每个表只描述一件事情。（非主键列要与主键有关系，约束主键与非主键）
		第三范式：非主键间消除传递依赖。在满足第二范式的前提下，除了主键之外的其他列消除传递依赖。（一个或多个非主键列能够推断另一个非主键列时，则另一个主键列就不写，即非主键间不能有依赖关系，约束非主键间）
			如：学号、姓名、语文、数学、总分不满足第三范式，因为语文、数学可以推断总分，应把总分去掉才满足。（实际上很多时候是保留总分的--反3NF）
			小结：1.范式越高，冗余越少，但表越多。
				  2.规范化与性能关系：性能比规范化更重要（反3NF）
				  
dual表：伪表，为了保证语句的完整性。如select 10*10；这里面没有表参与，等价于 select 10*10 from dual；


			
			
			


  